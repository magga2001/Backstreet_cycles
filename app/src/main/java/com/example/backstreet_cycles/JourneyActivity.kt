package com.example.backstreet_cycles

import android.annotation.SuppressLint
import android.content.Intent
import android.location.Location
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.LinearLayout
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.ViewModelProvider
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.backstreet_cycles.adapter.ManeuverAdapter
import com.example.backstreet_cycles.model.MapHelper
import com.example.backstreet_cycles.viewModel.JourneyViewModel
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.mapbox.maps.MapView
import com.mapbox.maps.MapboxMap
import com.mapbox.maps.Style
import com.mapbox.maps.extension.observable.eventdata.MapLoadingErrorEventData
import com.mapbox.maps.plugin.delegates.listeners.OnMapLoadErrorListener
import com.mapbox.maps.plugin.locationcomponent.OnIndicatorPositionChangedListener
import com.mapbox.maps.plugin.locationcomponent.location
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.MapboxNavigationProvider
import com.mapbox.navigation.core.directions.session.RoutesObserver
import com.mapbox.navigation.core.replay.MapboxReplayer
import com.mapbox.navigation.core.replay.ReplayLocationEngine
import com.mapbox.navigation.core.replay.route.ReplayProgressObserver
import com.mapbox.navigation.core.trip.session.LocationMatcherResult
import com.mapbox.navigation.core.trip.session.LocationObserver
import com.mapbox.navigation.core.trip.session.RouteProgressObserver
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import com.mapbox.navigation.ui.maps.route.RouteLayerConstants.TOP_LEVEL_ROUTE_LINE_LAYER_ID
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView
import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineOptions
import com.mapbox.navigation.ui.maps.route.line.model.RouteLine
import com.mapbox.navigation.ui.maps.route.line.model.RouteLineColorResources
import com.mapbox.navigation.ui.maps.route.line.model.RouteLineResources
import kotlinx.android.synthetic.main.journey_bottom_sheet.*


class JourneyActivity : AppCompatActivity() {
    /**
     * Debug tool used to play, pause and seek route progress events that can be used to produce mocked location updates along the route.
     */
    private val mapboxReplayer = MapboxReplayer()

    /**
     * Debug observer that makes sure the replayer has always an up-to-date information to generate mock updates.
     */
    private val replayProgressObserver = ReplayProgressObserver(mapboxReplayer)

    /**
     * Debug tool that mocks location updates with an input from the [mapboxReplayer].
     */
    private val replayLocationEngine = ReplayLocationEngine(mapboxReplayer)

    private val currentRoute by lazy {
        MapHelper.currentRoute
    }

    /**
     * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
     * to the Maps SDK in order to update the user location indicator on the map.
     */
    private val navigationLocationProvider by lazy {
        NavigationLocationProvider()
    }

    //Future interaction with current location
    private val locationComponent by lazy {
        mapView?.location?.apply {
            setLocationProvider(navigationLocationProvider)
            // When true, the blue circular puck is shown on the map. If set to false, user
            // location in the form of puck will not be shown on the map.
            enabled = true
        }
    }

    /**
     * Mapbox Navigation entry point. There should only be one instance of this object for the app.
     * You can use [MapboxNavigationProvider] to help create and obtain that instance.
     */
    private lateinit var mapboxNavigation: MapboxNavigation

    /**
     * RouteLine: Various route line related options can be customized here including applying
     * route line color customizations.
     */
    private val routeLineResources: RouteLineResources by lazy {
        RouteLineResources.Builder()
            /**
             * Route line related colors can be customized via the [RouteLineColorResources]. If using the
             * default colors the [RouteLineColorResources] does not need to be set as seen here, the
             * defaults will be used internally by the builder.
             */
            .routeLineColorResources(RouteLineColorResources.Builder().build())
            .build()
    }

    /**
     * RouteLine: Additional route line options are available through the MapboxRouteLineOptions.
     * Notice here the withRouteLineBelowLayerId option. The map is made up of layers. In this
     * case the route line will be placed below the "road-label" layer which is a good default
     * for the most common Mapbox navigation related maps. You should consider if this should be
     * changed for your use case especially if you are using a custom map style.
     */
    private val options: MapboxRouteLineOptions by lazy {
        MapboxRouteLineOptions.Builder(this)
            /**
             * Remove this line and [onPositionChangedListener] if you don't wish to show the
             * vanishing route line feature
             */
            .withVanishingRouteLineEnabled(true)
            .withRouteLineResources(routeLineResources)
            .withRouteLineBelowLayerId("road-label")
            .build()
    }

    /**
     * RouteLine: This class is responsible for rendering route line related mutations generated
     * by the [routeLineApi]
     */
    private val routeLineView by lazy {
        MapboxRouteLineView(options)
    }

    /**
     * RouteLine: This class is responsible for generating route line related data which must be
     * rendered by the [routeLineView] in order to visualize the route line on the map.
     */
    private val routeLineApi: MapboxRouteLineApi by lazy {
        MapboxRouteLineApi(options)
    }

    /**
     * RouteArrow: This class is responsible for generating data related to maneuver arrows. The
     * data generated must be rendered by the [routeArrowView] in order to apply mutations to
     * the map.
     */
    private val routeArrowApi: MapboxRouteArrowApi by lazy {
        MapboxRouteArrowApi()
    }

    /**
     * RouteArrow: Customization of the maneuver arrow(s) can be done using the
     * [RouteArrowOptions]. Here the above layer ID is used to determine where in the map layer
     * stack the arrows appear. Above the layer of the route traffic line is being used here. Your
     * use case may necessitate adjusting this to a different layer position.
     */
    private val routeArrowOptions by lazy {
        RouteArrowOptions.Builder(this)
            .withAboveLayerId(TOP_LEVEL_ROUTE_LINE_LAYER_ID)
            .build()
    }

    /**
     * RouteArrow: This class is responsible for rendering the arrow related mutations generated
     * by the [routeArrowApi]
     */
    private val routeArrowView: MapboxRouteArrowView by lazy {
        MapboxRouteArrowView(routeArrowOptions)
    }

    /**
     * RouteLine: This is one way to keep the route(s) appearing on the map in sync with
     * MapboxNavigation. When this observer is called the route data is used to draw route(s)
     * on the map.
     */
    private val routesObserver: RoutesObserver = RoutesObserver { routeUpdateResult ->
        // RouteLine: wrap the DirectionRoute objects and pass them
        // to the MapboxRouteLineApi to generate the data necessary to draw the route(s)
        // on the map.
        val routeLines = routeUpdateResult.routes.map { RouteLine(it, null) }

        routeLineApi.setRoutes(
            routeLines
        ) { value ->
            // RouteLine: The MapboxRouteLineView expects a non-null reference to the map style.
            // the data generated by the call to the MapboxRouteLineApi above must be rendered
            // by the MapboxRouteLineView in order to visualize the changes on the map.
            mapboxMap?.getStyle()?.apply {
                routeLineView.renderRouteDrawData(this, value)
            }
        }
    }

    /**
     * RouteLine: This listener is necessary only when enabling the vanishing route line feature
     * which changes the color of the route line behind the puck during navigation. If this
     * option is set to `false` (the default) in MapboxRouteLineOptions then it is not necessary
     * to use this listener.
     */
    //Future interaction with current location
    private val onPositionChangedListener = OnIndicatorPositionChangedListener { point ->
        val result = routeLineApi.updateTraveledRouteLine(point)
        mapboxMap?.getStyle()?.apply {
            // Render the result to update the map.
            routeLineView.renderRouteLineUpdate(this, result)
        }
    }

    private val routeProgressObserver = RouteProgressObserver { routeProgress ->
        // RouteLine: This line is only necessary if the vanishing route line feature
        // is enabled.
        routeLineApi.updateWithRouteProgress(routeProgress) { result ->
            mapboxMap?.getStyle()?.apply {
                routeLineView.renderRouteLineUpdate(this, result)
            }
        }

        // RouteArrow: The next maneuver arrows are driven by route progress events.
        // Generate the next maneuver arrow update data and pass it to the view class
        // to visualize the updates on the map.
        val arrowUpdate = routeArrowApi.addUpcomingManeuverArrow(routeProgress)
        mapboxMap?.getStyle()?.apply {
            // Render the result to update the map.
            routeArrowView.renderManeuverUpdate(this, arrowUpdate)
        }
    }

    private val locationObserver = object : LocationObserver {
        override fun onNewRawLocation(rawLocation: Location) {}
        override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
            val enhancedLocation = locationMatcherResult.enhancedLocation
            navigationLocationProvider.changePosition(
                enhancedLocation,
                locationMatcherResult.keyPoints,
            )
            //Stick the camera to the specific view point
//            updateCamera(
//                Journey.centerPoint,
//                enhancedLocation.bearing.toDouble()
//            )
        }
    }

    private var mapView: MapView?= null
    private var mapboxMap: MapboxMap? = null
    private lateinit var journeyViewModel: JourneyViewModel
    private var sheetBehavior: BottomSheetBehavior<*>? = null
    private lateinit var mAdapter: ManeuverAdapter
    private lateinit var recycleView: RecyclerView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_journey)
        mapView = findViewById(R.id.mapView)
        mapboxMap = mapView?.getMapboxMap()
        journeyViewModel = ViewModelProvider(this).get(JourneyViewModel::class.java)
        journeyViewModel.checkPermission(this, activity = this)
        mapboxNavigation = journeyViewModel.initialiseMapboxNavigation()
        init()

        recycleView = findViewById(R.id.maneuver_recycling_view)

        val bottomView = findViewById<View>(R.id.bottom_sheet_view)
        sheetBehavior = BottomSheetBehavior.from(bottomView)

//        setBottomSheetAndCallBackBottomSheetBehaviour()

        mAdapter = ManeuverAdapter(this, MapHelper.maneuvers)
        recycleView.layoutManager = LinearLayoutManager(this)
        recycleView.adapter = mAdapter
    }

//    /**
//     * set bottom sheet behavior and state
//     */
//    private fun setBottomSheetAndCallBackBottomSheetBehaviour() {
//
//
//        sheetBehavior?.state = BottomSheetBehavior.STATE_HIDDEN
//
//        //callback
//        sheetBehavior?.setBottomSheetCallback(object :
//            BottomSheetBehavior.BottomSheetCallback() {
//            override fun onStateChanged(bottomSheet: View, newState: Int) {
//                if (newState == BottomSheetBehavior.STATE_COLLAPSED) {
//                    bottomSheetCollapsed()
//                }
//            }
//
//            override fun onSlide(bottomSheet: View, slideOffset: Float) {}
//        })
//    }
//
//   private fun isExpendCollapse(){
//        if (sheetBehavior?.state == BottomSheetBehavior.STATE_COLLAPSED) {
//            bottomSheetExpand()
//        } else {
//            bottomSheetCollapsed()
//        }
//    }
//
//    private fun bottomSheetExpand() {
//        sheetBehavior?.state = BottomSheetBehavior.STATE_EXPANDED
//    }
//
//    private fun bottomSheetCollapsed() {
//        sheetBehavior?.state = BottomSheetBehavior.STATE_COLLAPSED
//    }

    private fun init() {
        initStyle()
        initNavigation()
        initListeners()
    }

    @SuppressLint("MissingPermission")
    private fun initStyle() {
        mapboxMap?.loadStyleUri(
            Style.MAPBOX_STREETS,
            {
//                updateCamera(MapRepository.centerPoint, null)
                journeyViewModel.updateCamera(MapHelper.centerPoint, null, mapView!!)
                startNavigation?.visibility = View.VISIBLE
                journeyViewModel.addAnnotationToMap(this, mapView!!)
            },
            object : OnMapLoadErrorListener {
                override fun onMapLoadError(eventData: MapLoadingErrorEventData) {
                    Log.e(
                        JourneyActivity::class.java.simpleName,
                        "Error loading map: " + eventData.message
                    )
                }
            }
        )
    }

    @SuppressLint("MissingPermission")
    private fun initNavigation() {
        mapboxNavigation.run {
            setRoutes(listOf(currentRoute))
            registerRoutesObserver(routesObserver)
            registerLocationObserver(locationObserver)
            registerRouteProgressObserver(routeProgressObserver)
            registerRouteProgressObserver(replayProgressObserver)
//            startTripSession()
        }
    }

    @SuppressLint("SetTextI18n")
    private fun initListeners() {
        startNavigation?.text = "Start Navigation"
        startNavigation?.setOnClickListener {
            val intent = Intent(this, NavigationActivity::class.java)
            startActivity(intent)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        //For future interaction with current location
        //locationComponent?.removeOnIndicatorPositionChangedListener(onPositionChangedListener)
        mapboxNavigation.run {
            // make sure to stop the trip session. In this case it is being called inside `onDestroy`.
//            stopTripSession()
            // make sure to unregister the routes observer you have registered.
            unregisterRoutesObserver(routesObserver)
            // make sure to unregister the location observer you have registered.
            unregisterLocationObserver(locationObserver)
            // make sure to unregister the route progress observer you have registered.
            unregisterRouteProgressObserver(routeProgressObserver)
            // make sure to unregister the route progress observer you have registered.
            unregisterRouteProgressObserver(replayProgressObserver)
        }
        //To destroy and not let it overlap to next mapbox activity
        MapboxNavigationProvider.destroy()
        mapboxReplayer.finish()
        routeLineView.cancel()
        routeLineApi.cancel()
        mapboxNavigation.setRoutes(listOf())
        mapboxNavigation.onDestroy()
    }

    //    private fun updateCamera(point: Point, bearing: Double?) {
//        val mapAnimationOptionsBuilder = MapAnimationOptions.Builder()
//        mapView?.camera?.easeTo(
//            CameraOptions.Builder()
//                .center(point)
//                .bearing(bearing)
////                .pitch(45.0)
//                .zoom(13.0)
//                .padding(EdgeInsets(1000.0, 0.0, 0.0, 0.0))
//                .build(),
//            mapAnimationOptionsBuilder.build()
//        )
//    }

//    private fun addAnnotationToMap() {
//        // Create an instance of the Annotation API and get the PointAnnotationManager.
//        val raw_bitmap = bitmapFromDrawableRes(this@JourneyActivity, R.drawable.dock_station) as Bitmap
//        val bitmap = Bitmap.createScaledBitmap(raw_bitmap, 150, 150, false)
//        bitmap.let {
//             // Set options for the resulting symbol layer.
//            val annotationApi = mapView?.annotations
//            val pointAnnotationManager = annotationApi?.createPointAnnotationManager()!!
//
//            for(i in 0 until MapRepository.wayPoints.size)
//            {
//                val pointAnnotationOptions: PointAnnotationOptions = PointAnnotationOptions()
//                    // Define a geographic coordinate.
//                    .withPoint(MapRepository.wayPoints[i])
//                    // Specify the bitmap you assigned to the point annotation
//                    // The bitmap will be added to map style automatically.
//                    .withIconImage(it)
//                    .withTextAnchor(textAnchor = TextAnchor.TOP)
//                    .withTextField((i + 65).toChar().toString())
//                    .withTextSize(10.00)
//                // Add the resulting pointAnnotation to the map.
//                pointAnnotationManager.create(pointAnnotationOptions)
//            }
//        }
//    }
//    private fun bitmapFromDrawableRes(context: Context, @DrawableRes resourceId: Int) =
//        convertDrawableToBitmap(AppCompatResources.getDrawable(context, resourceId))
//
//    private fun convertDrawableToBitmap(sourceDrawable: Drawable?): Bitmap? {
//        if (sourceDrawable == null) {
//            return null
//        }
//        return if (sourceDrawable is BitmapDrawable) {
//            sourceDrawable.bitmap
//        } else {
//            // copying drawable object to not manipulate on the same reference
//            val constantState = sourceDrawable.constantState ?: return null
//            val drawable = constantState.newDrawable().mutate()
//            val bitmap: Bitmap = Bitmap.createBitmap(
//                drawable.intrinsicWidth, drawable.intrinsicHeight,
//                Bitmap.Config.ARGB_8888
//            )
//            val canvas = Canvas(bitmap)
//            drawable.setBounds(0, 0, canvas.width, canvas.height)
//            drawable.draw(canvas)
//            bitmap
//        }
//    }
}